name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Backend
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/mean-backend:latest

    - name: Build and push Frontend
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/mean-frontend:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Deploy to VM
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.VM_HOST }}
        username: ${{ secrets.VM_USERNAME }}
        key: ${{ secrets.VM_SSH_KEY }}
        script: |
          # Pull latest images
          docker pull ${{ secrets.DOCKER_USERNAME }}/mean-backend:latest
          docker pull ${{ secrets.DOCKER_USERNAME }}/mean-frontend:latest
          
          # Stop and remove existing containers
          # Note: This assumes docker-compose is used on the server. 
          # You might need to copy docker-compose.yml to the server first or have it in the repo clone on server.
          # For simplicity, we'll assume the repo is cloned/pulled on the server or we just restart containers.
          
          # A more robust approach:
          # 1. Copy docker-compose.yml to server
          # 2. Run docker-compose up -d --pull always
          
          echo "Deployment script placeholder. Ensure docker-compose.yml is present on VM."
          # docker-compose down
          # docker-compose up -d --pull always
